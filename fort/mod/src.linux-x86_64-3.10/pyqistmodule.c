/* File: pyqistmodule.c
 * This file is auto-generated with f2py (version:1.26.2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Tue Dec 10 21:16:53 2024
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */

/* Unconditionally included */
#include <Python.h>
#include <numpy/npy_os.h>

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "fortranobject.h"
#include <string.h>
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *pyqist_error;
static PyObject *pyqist_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef char * string;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
\
#define FAILNULL(p) do {                                            \
    if ((p) == NULL) {                                              \
        PyErr_SetString(PyExc_MemoryError, "NULL pointer found");   \
        goto capi_fail;                                             \
    }                                                               \
} while (0)

#define STRINGMALLOC(str,len)\
    if ((str = (string)malloc(len+1)) == NULL) {\
        PyErr_SetString(PyExc_MemoryError, "out of memory");\
        goto capi_fail;\
    } else {\
        (str)[len] = '\0';\
    }

/* See fortranobject.h for definitions. The macros here are provided for BC. */
#define rank f2py_rank
#define shape f2py_shape
#define fshape f2py_shape
#define len f2py_len
#define flen f2py_flen
#define slen f2py_slen
#define size f2py_size

#define STRINGFREE(str) do {if (!(str == NULL)) free(str);} while (0)

/*
STRINGPADN replaces null values with padding values from the right.

`to` must have size of at least N bytes.

If the `to[N-1]` has null value, then replace it and all the
preceding, nulls with the given padding.

STRINGPADN(to, N, PADDING, NULLVALUE) is an inverse operation.
*/
#define STRINGPADN(to, N, NULLVALUE, PADDING)                   \
    do {                                                        \
        int _m = (N);                                           \
        char *_to = (to);                                       \
        for (_m -= 1; _m >= 0 && _to[_m] == NULLVALUE; _m--) {  \
             _to[_m] = PADDING;                                 \
        }                                                       \
    } while (0)

#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

/*
STRINGCOPYN copies N bytes.

`to` and `from` buffers must have sizes of at least N bytes.
*/
#define STRINGCOPYN(to,from,N)                                  \
    do {                                                        \
        int _m = (N);                                           \
        char *_to = (to);                                       \
        char *_from = (from);                                   \
        FAILNULL(_to); FAILNULL(_from);                         \
        (void)strncpy(_to, _from, _m);             \
    } while (0)


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
/*
  Create a new string buffer `str` of at most length `len` from a
  Python string-like object `obj`.

  The string buffer has given size (len) or the size of inistr when len==-1.

  The string buffer is padded with blanks: in Fortran, trailing blanks
  are insignificant contrary to C nulls.
 */
static int
string_from_pyobj(string *str, int *len, const string inistr, PyObject *obj,
                  const char *errmess)
{
    PyObject *tmp = NULL;
    string buf = NULL;
    npy_intp n = -1;
#ifdef DEBUGCFUNCS
fprintf(stderr,"string_from_pyobj(str='%s',len=%d,inistr='%s',obj=%p)\n",
               (char*)str, *len, (char *)inistr, obj);
#endif
    if (obj == Py_None) {
        n = strlen(inistr);
        buf = inistr;
    }
    else if (PyArray_Check(obj)) {
        PyArrayObject *arr = (PyArrayObject *)obj;
        if (!ISCONTIGUOUS(arr)) {
            PyErr_SetString(PyExc_ValueError,
                            "array object is non-contiguous.");
            goto capi_fail;
        }
        n = PyArray_NBYTES(arr);
        buf = PyArray_DATA(arr);
        n = strnlen(buf, n);
    }
    else {
        if (PyBytes_Check(obj)) {
            tmp = obj;
            Py_INCREF(tmp);
        }
        else if (PyUnicode_Check(obj)) {
            tmp = PyUnicode_AsASCIIString(obj);
        }
        else {
            PyObject *tmp2;
            tmp2 = PyObject_Str(obj);
            if (tmp2) {
                tmp = PyUnicode_AsASCIIString(tmp2);
                Py_DECREF(tmp2);
            }
            else {
                tmp = NULL;
            }
        }
        if (tmp == NULL) goto capi_fail;
        n = PyBytes_GET_SIZE(tmp);
        buf = PyBytes_AS_STRING(tmp);
    }
    if (*len == -1) {
        /* TODO: change the type of `len` so that we can remove this */
        if (n > NPY_MAX_INT) {
            PyErr_SetString(PyExc_OverflowError,
                            "object too large for a 32-bit int");
            goto capi_fail;
        }
        *len = n;
    }
    else if (*len < n) {
        /* discard the last (len-n) bytes of input buf */
        n = *len;
    }
    if (n < 0 || *len < 0 || buf == NULL) {
        goto capi_fail;
    }
    STRINGMALLOC(*str, *len);  // *str is allocated with size (*len + 1)
    if (n < *len) {
        /*
          Pad fixed-width string with nulls. The caller will replace
          nulls with blanks when the corresponding argument is not
          intent(c).
        */
        memset(*str + n, '\0', *len - n);
    }
    STRINGCOPYN(*str, buf, n);
    Py_XDECREF(tmp);
    return 1;
capi_fail:
    Py_XDECREF(tmp);
    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = pyqist_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}

static int
double_from_pyobj(double* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
        *v = PyFloat_AsDouble(obj);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    tmp = PyNumber_Float(obj);
    if (tmp) {
        *v = PyFloat_AsDouble(tmp);
        Py_DECREF(tmp);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj)) {
        PyErr_Clear();
        tmp = PyObject_GetAttrString(obj,"real");
    }
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) {
        /*pass*/;
    }
    else if (PySequence_Check(obj)) {
        PyErr_Clear();
        tmp = PySequence_GetItem(obj, 0);
    }

    if (tmp) {
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = pyqist_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int
int_from_pyobj(int* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;

    if (PyLong_Check(obj)) {
        *v = Npy__PyLong_AsInt(obj);
        return !(*v == -1 && PyErr_Occurred());
    }

    tmp = PyNumber_Long(obj);
    if (tmp) {
        *v = Npy__PyLong_AsInt(tmp);
        Py_DECREF(tmp);
        return !(*v == -1 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj)) {
        PyErr_Clear();
        tmp = PyObject_GetAttrString(obj,"real");
    }
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) {
        /*pass*/;
    }
    else if (PySequence_Check(obj)) {
        PyErr_Clear();
        tmp = PySequence_GetItem(obj, 0);
    }

    if (tmp) {
        if (int_from_pyobj(v, tmp, errmess)) {
            Py_DECREF(tmp);
            return 1;
        }
        Py_DECREF(tmp);
    }

    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = pyqist_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/********************************* pw_init_v *********************************/
static char doc_f2py_rout_pyqist_pq_pw_init_v[] = "\
pw_init_v(t0,tf,trajfile,kvtaufile)\n\nWrapper for ``pw_init_v``.\
\n\nParameters\n----------\n"
"t0 : input float\n"
"tf : input float\n"
"trajfile : input string(len=-1)\n"
"kvtaufile : input string(len=-1)";
/*  */
static PyObject *f2py_rout_pyqist_pq_pw_init_v(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,string,string,size_t,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double t0 = 0;
    PyObject *t0_capi = Py_None;
    double tf = 0;
    PyObject *tf_capi = Py_None;
    string trajfile = NULL;
    int slen(trajfile);
    PyObject *trajfile_capi = Py_None;
    string kvtaufile = NULL;
    int slen(kvtaufile);
    PyObject *kvtaufile_capi = Py_None;
    static char *capi_kwlist[] = {"t0","tf","trajfile","kvtaufile",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|:pyqist.pq.pw_init_v",\
        capi_kwlist,&t0_capi,&tf_capi,&trajfile_capi,&kvtaufile_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable trajfile */
    slen(trajfile) = -1;
    f2py_success = string_from_pyobj(&trajfile,&slen(trajfile),"",trajfile_capi,"string_from_pyobj failed in converting 3rd argument`trajfile' of pyqist.pq.pw_init_v to C string");
    if (f2py_success) {
        STRINGPADN(trajfile, slen(trajfile), '\0', ' ');
    /* Processing variable kvtaufile */
    slen(kvtaufile) = -1;
    f2py_success = string_from_pyobj(&kvtaufile,&slen(kvtaufile),"",kvtaufile_capi,"string_from_pyobj failed in converting 4th argument`kvtaufile' of pyqist.pq.pw_init_v to C string");
    if (f2py_success) {
        STRINGPADN(kvtaufile, slen(kvtaufile), '\0', ' ');
    /* Processing variable t0 */
        f2py_success = double_from_pyobj(&t0,t0_capi,"pyqist.pq.pw_init_v() 1st argument (t0) can't be converted to double");
    if (f2py_success) {
    /* Processing variable tf */
        f2py_success = double_from_pyobj(&tf,tf_capi,"pyqist.pq.pw_init_v() 2nd argument (tf) can't be converted to double");
    if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(&t0,&tf,trajfile,kvtaufile,slen(trajfile),slen(kvtaufile));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    } /*if (f2py_success) of tf*/
    /* End of cleaning variable tf */
    } /*if (f2py_success) of t0*/
    /* End of cleaning variable t0 */
        STRINGFREE(kvtaufile);
    }  /*if (f2py_success) of kvtaufile*/
    /* End of cleaning variable kvtaufile */
        STRINGFREE(trajfile);
    }  /*if (f2py_success) of trajfile*/
    /* End of cleaning variable trajfile */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of pw_init_v ******************************/

/********************************* pw_init_n *********************************/
static char doc_f2py_rout_pyqist_pq_pw_init_n[] = "\
pw_init_n(namefile)\n\nWrapper for ``pw_init_n``.\
\n\nParameters\n----------\n"
"namefile : input string(len=-1)";
/*  */
static PyObject *f2py_rout_pyqist_pq_pw_init_n(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    string namefile = NULL;
    int slen(namefile);
    PyObject *namefile_capi = Py_None;
    static char *capi_kwlist[] = {"namefile",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:pyqist.pq.pw_init_n",\
        capi_kwlist,&namefile_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable namefile */
    slen(namefile) = -1;
    f2py_success = string_from_pyobj(&namefile,&slen(namefile),"",namefile_capi,"string_from_pyobj failed in converting 1st argument`namefile' of pyqist.pq.pw_init_n to C string");
    if (f2py_success) {
        STRINGPADN(namefile, slen(namefile), '\0', ' ');
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(namefile,slen(namefile));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
        STRINGFREE(namefile);
    }  /*if (f2py_success) of namefile*/
    /* End of cleaning variable namefile */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of pw_init_n ******************************/

/********************************** pw_state **********************************/
static char doc_f2py_rout_pyqist_pq_pw_state[] = "\
res = pw_state(tau)\n\nWrapper for ``pw_state``.\
\n\nParameters\n----------\n"
"tau : input float\n"
"\nReturns\n-------\n"
"res : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_state(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double pw_statef2pywrap = 0;
    double tau = 0;
    PyObject *tau_capi = Py_None;
    static char *capi_kwlist[] = {"tau",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:pyqist.pq.pw_state",\
        capi_kwlist,&tau_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable tau */
        f2py_success = double_from_pyobj(&tau,tau_capi,"pyqist.pq.pw_state() 1st argument (tau) can't be converted to double");
    if (f2py_success) {
    /* Processing variable pw_statef2pywrap */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(&pw_statef2pywrap,&tau);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("d",pw_statef2pywrap);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    /* End of cleaning variable pw_statef2pywrap */
    } /*if (f2py_success) of tau*/
    /* End of cleaning variable tau */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of pw_state ******************************/

/*********************************** pw_stm ***********************************/
static char doc_f2py_rout_pyqist_pq_pw_stm[] = "\
res = pw_stm(tau)\n\nWrapper for ``pw_stm``.\
\n\nParameters\n----------\n"
"tau : input float\n"
"\nReturns\n-------\n"
"res : rank-2 array('d') with bounds (8,8) and pw_stmf2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_stm(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_stmf2pywrap = NULL;
    npy_intp pw_stmf2pywrap_Dims[2] = {-1, -1};
    const int pw_stmf2pywrap_Rank = 2;
    PyArrayObject *capi_pw_stmf2pywrap_as_array = NULL;
    int capi_pw_stmf2pywrap_intent = 0;
    double tau = 0;
    PyObject *tau_capi = Py_None;
    static char *capi_kwlist[] = {"tau",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:pyqist.pq.pw_stm",\
        capi_kwlist,&tau_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable tau */
        f2py_success = double_from_pyobj(&tau,tau_capi,"pyqist.pq.pw_stm() 1st argument (tau) can't be converted to double");
    if (f2py_success) {
    /* Processing variable pw_stmf2pywrap */
    pw_stmf2pywrap_Dims[0]=8,pw_stmf2pywrap_Dims[1]=8;
    capi_pw_stmf2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stm: failed to create array from the hidden `pw_stmf2pywrap`";
    capi_pw_stmf2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_stmf2pywrap_Dims,pw_stmf2pywrap_Rank,  capi_pw_stmf2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_stmf2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_stmf2pywrap = (double *)(PyArray_DATA(capi_pw_stmf2pywrap_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_stmf2pywrap,&tau);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_stmf2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_pw_stmf2pywrap_as_array == NULL) ... else of pw_stmf2pywrap */
    /* End of cleaning variable pw_stmf2pywrap */
    } /*if (f2py_success) of tau*/
    /* End of cleaning variable tau */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of pw_stm *******************************/

/*********************************** pw_stt ***********************************/
static char doc_f2py_rout_pyqist_pq_pw_stt[] = "\
res = pw_stt(tau)\n\nWrapper for ``pw_stt``.\
\n\nParameters\n----------\n"
"tau : input float\n"
"\nReturns\n-------\n"
"res : rank-3 array('d') with bounds (8,8,8) and pw_sttf2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_stt(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_sttf2pywrap = NULL;
    npy_intp pw_sttf2pywrap_Dims[3] = {-1, -1, -1};
    const int pw_sttf2pywrap_Rank = 3;
    PyArrayObject *capi_pw_sttf2pywrap_as_array = NULL;
    int capi_pw_sttf2pywrap_intent = 0;
    double tau = 0;
    PyObject *tau_capi = Py_None;
    static char *capi_kwlist[] = {"tau",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:pyqist.pq.pw_stt",\
        capi_kwlist,&tau_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable tau */
        f2py_success = double_from_pyobj(&tau,tau_capi,"pyqist.pq.pw_stt() 1st argument (tau) can't be converted to double");
    if (f2py_success) {
    /* Processing variable pw_sttf2pywrap */
    pw_sttf2pywrap_Dims[0]=8,pw_sttf2pywrap_Dims[1]=8,pw_sttf2pywrap_Dims[2]=8;
    capi_pw_sttf2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stt: failed to create array from the hidden `pw_sttf2pywrap`";
    capi_pw_sttf2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_sttf2pywrap_Dims,pw_sttf2pywrap_Rank,  capi_pw_sttf2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_sttf2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_sttf2pywrap = (double *)(PyArray_DATA(capi_pw_sttf2pywrap_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_sttf2pywrap,&tau);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_sttf2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_pw_sttf2pywrap_as_array == NULL) ... else of pw_sttf2pywrap */
    /* End of cleaning variable pw_sttf2pywrap */
    } /*if (f2py_success) of tau*/
    /* End of cleaning variable tau */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of pw_stt *******************************/

/********************************** pw_stm_i **********************************/
static char doc_f2py_rout_pyqist_pq_pw_stm_i[] = "\
res = pw_stm_i(tau)\n\nWrapper for ``pw_stm_i``.\
\n\nParameters\n----------\n"
"tau : input float\n"
"\nReturns\n-------\n"
"res : rank-2 array('d') with bounds (8,8) and pw_stm_if2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_stm_i(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_stm_if2pywrap = NULL;
    npy_intp pw_stm_if2pywrap_Dims[2] = {-1, -1};
    const int pw_stm_if2pywrap_Rank = 2;
    PyArrayObject *capi_pw_stm_if2pywrap_as_array = NULL;
    int capi_pw_stm_if2pywrap_intent = 0;
    double tau = 0;
    PyObject *tau_capi = Py_None;
    static char *capi_kwlist[] = {"tau",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:pyqist.pq.pw_stm_i",\
        capi_kwlist,&tau_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable tau */
        f2py_success = double_from_pyobj(&tau,tau_capi,"pyqist.pq.pw_stm_i() 1st argument (tau) can't be converted to double");
    if (f2py_success) {
    /* Processing variable pw_stm_if2pywrap */
    pw_stm_if2pywrap_Dims[0]=8,pw_stm_if2pywrap_Dims[1]=8;
    capi_pw_stm_if2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stm_i: failed to create array from the hidden `pw_stm_if2pywrap`";
    capi_pw_stm_if2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_stm_if2pywrap_Dims,pw_stm_if2pywrap_Rank,  capi_pw_stm_if2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_stm_if2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_stm_if2pywrap = (double *)(PyArray_DATA(capi_pw_stm_if2pywrap_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_stm_if2pywrap,&tau);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_stm_if2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_pw_stm_if2pywrap_as_array == NULL) ... else of pw_stm_if2pywrap */
    /* End of cleaning variable pw_stm_if2pywrap */
    } /*if (f2py_success) of tau*/
    /* End of cleaning variable tau */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of pw_stm_i ******************************/

/********************************** pw_stt_i **********************************/
static char doc_f2py_rout_pyqist_pq_pw_stt_i[] = "\
res = pw_stt_i(tau)\n\nWrapper for ``pw_stt_i``.\
\n\nParameters\n----------\n"
"tau : input float\n"
"\nReturns\n-------\n"
"res : rank-3 array('d') with bounds (8,8,8) and pw_stt_if2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_stt_i(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_stt_if2pywrap = NULL;
    npy_intp pw_stt_if2pywrap_Dims[3] = {-1, -1, -1};
    const int pw_stt_if2pywrap_Rank = 3;
    PyArrayObject *capi_pw_stt_if2pywrap_as_array = NULL;
    int capi_pw_stt_if2pywrap_intent = 0;
    double tau = 0;
    PyObject *tau_capi = Py_None;
    static char *capi_kwlist[] = {"tau",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:pyqist.pq.pw_stt_i",\
        capi_kwlist,&tau_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable tau */
        f2py_success = double_from_pyobj(&tau,tau_capi,"pyqist.pq.pw_stt_i() 1st argument (tau) can't be converted to double");
    if (f2py_success) {
    /* Processing variable pw_stt_if2pywrap */
    pw_stt_if2pywrap_Dims[0]=8,pw_stt_if2pywrap_Dims[1]=8,pw_stt_if2pywrap_Dims[2]=8;
    capi_pw_stt_if2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stt_i: failed to create array from the hidden `pw_stt_if2pywrap`";
    capi_pw_stt_if2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_stt_if2pywrap_Dims,pw_stt_if2pywrap_Rank,  capi_pw_stt_if2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_stt_if2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_stt_if2pywrap = (double *)(PyArray_DATA(capi_pw_stt_if2pywrap_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_stt_if2pywrap,&tau);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_stt_if2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_pw_stt_if2pywrap_as_array == NULL) ... else of pw_stt_if2pywrap */
    /* End of cleaning variable pw_stt_if2pywrap */
    } /*if (f2py_success) of tau*/
    /* End of cleaning variable tau */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of pw_stt_i ******************************/

/******************************** pw_prop_once ********************************/
static char doc_f2py_rout_pyqist_pq_pw_prop_once[] = "\
res = pw_prop_once(ta,tb,xa,[order])\n\nWrapper for ``pw_prop_once``.\
\n\nParameters\n----------\n"
"ta : input float\n"
"tb : input float\n"
"xa : input rank-1 array('d') with bounds (8)\n"
"\nOther Parameters\n----------------\n"
"order : input int\n"
"\nReturns\n-------\n"
"res : rank-1 array('d') with bounds (8) and pw_prop_oncef2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_prop_once(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_prop_oncef2pywrap = NULL;
    npy_intp pw_prop_oncef2pywrap_Dims[1] = {-1};
    const int pw_prop_oncef2pywrap_Rank = 1;
    PyArrayObject *capi_pw_prop_oncef2pywrap_as_array = NULL;
    int capi_pw_prop_oncef2pywrap_intent = 0;
    double ta = 0;
    PyObject *ta_capi = Py_None;
    double tb = 0;
    PyObject *tb_capi = Py_None;
    double *xa = NULL;
    npy_intp xa_Dims[1] = {-1};
    const int xa_Rank = 1;
    PyArrayObject *capi_xa_as_array = NULL;
    int capi_xa_intent = 0;
    PyObject *xa_capi = Py_None;
    int order = 0;
    PyObject *order_capi = Py_None;
    static char *capi_kwlist[] = {"ta","tb","xa","order",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:pyqist.pq.pw_prop_once",\
        capi_kwlist,&ta_capi,&tb_capi,&xa_capi,&order_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable ta */
        f2py_success = double_from_pyobj(&ta,ta_capi,"pyqist.pq.pw_prop_once() 1st argument (ta) can't be converted to double");
    if (f2py_success) {
    /* Processing variable tb */
        f2py_success = double_from_pyobj(&tb,tb_capi,"pyqist.pq.pw_prop_once() 2nd argument (tb) can't be converted to double");
    if (f2py_success) {
    /* Processing variable xa */
    xa_Dims[0]=8;
    capi_xa_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_prop_once: failed to create array from the 3rd argument `xa`";
    capi_xa_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,xa_Dims,xa_Rank,  capi_xa_intent,xa_capi,capi_errmess);
    if (capi_xa_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        xa = (double *)(PyArray_DATA(capi_xa_as_array));

    /* Processing variable order */
    if (order_capi != Py_None)
        f2py_success = int_from_pyobj(&order,order_capi,"pyqist.pq.pw_prop_once() 1st keyword (order) can't be converted to int");
    if (f2py_success) {
    /* Processing variable pw_prop_oncef2pywrap */
    pw_prop_oncef2pywrap_Dims[0]=8;
    capi_pw_prop_oncef2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_prop_once: failed to create array from the hidden `pw_prop_oncef2pywrap`";
    capi_pw_prop_oncef2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_prop_oncef2pywrap_Dims,pw_prop_oncef2pywrap_Rank,  capi_pw_prop_oncef2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_prop_oncef2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_prop_oncef2pywrap = (double *)(PyArray_DATA(capi_pw_prop_oncef2pywrap_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_prop_oncef2pywrap,&ta,&tb,xa,&order);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_prop_oncef2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_pw_prop_oncef2pywrap_as_array == NULL) ... else of pw_prop_oncef2pywrap */
    /* End of cleaning variable pw_prop_oncef2pywrap */
    } /*if (f2py_success) of order*/
    /* End of cleaning variable order */
    if((PyObject *)capi_xa_as_array!=xa_capi) {
        Py_XDECREF(capi_xa_as_array); }
    }  /* if (capi_xa_as_array == NULL) ... else of xa */
    /* End of cleaning variable xa */
    } /*if (f2py_success) of tb*/
    /* End of cleaning variable tb */
    } /*if (f2py_success) of ta*/
    /* End of cleaning variable ta */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of pw_prop_once ****************************/

/******************************** pw_prop_many ********************************/
static char doc_f2py_rout_pyqist_pq_pw_prop_many[] = "\
res = pw_prop_many(ta,tb,xa,[order])\n\nWrapper for ``pw_prop_many``.\
\n\nParameters\n----------\n"
"ta : input float\n"
"tb : input float\n"
"xa : input rank-2 array('d') with bounds (f2py_xa_d0,f2py_xa_d1)\n"
"\nOther Parameters\n----------------\n"
"order : input int\n"
"\nReturns\n-------\n"
"res : rank-2 array('d') with bounds (8,size(xa, 2)) and pw_prop_manyf2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_prop_many(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_prop_manyf2pywrap = NULL;
    npy_intp pw_prop_manyf2pywrap_Dims[2] = {-1, -1};
    const int pw_prop_manyf2pywrap_Rank = 2;
    PyArrayObject *capi_pw_prop_manyf2pywrap_as_array = NULL;
    int capi_pw_prop_manyf2pywrap_intent = 0;
    double ta = 0;
    PyObject *ta_capi = Py_None;
    double tb = 0;
    PyObject *tb_capi = Py_None;
    double *xa = NULL;
    npy_intp xa_Dims[2] = {-1, -1};
    const int xa_Rank = 2;
    PyArrayObject *capi_xa_as_array = NULL;
    int capi_xa_intent = 0;
    PyObject *xa_capi = Py_None;
    int order = 0;
    PyObject *order_capi = Py_None;
    int f2py_xa_d0 = 0;
    int f2py_xa_d1 = 0;
    static char *capi_kwlist[] = {"ta","tb","xa","order",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:pyqist.pq.pw_prop_many",\
        capi_kwlist,&ta_capi,&tb_capi,&xa_capi,&order_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable ta */
        f2py_success = double_from_pyobj(&ta,ta_capi,"pyqist.pq.pw_prop_many() 1st argument (ta) can't be converted to double");
    if (f2py_success) {
    /* Processing variable tb */
        f2py_success = double_from_pyobj(&tb,tb_capi,"pyqist.pq.pw_prop_many() 2nd argument (tb) can't be converted to double");
    if (f2py_success) {
    /* Processing variable xa */
    ;
    capi_xa_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_prop_many: failed to create array from the 3rd argument `xa`";
    capi_xa_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,xa_Dims,xa_Rank,  capi_xa_intent,xa_capi,capi_errmess);
    if (capi_xa_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        xa = (double *)(PyArray_DATA(capi_xa_as_array));

    /* Processing variable order */
    if (order_capi != Py_None)
        f2py_success = int_from_pyobj(&order,order_capi,"pyqist.pq.pw_prop_many() 1st keyword (order) can't be converted to int");
    if (f2py_success) {
    /* Processing variable pw_prop_manyf2pywrap */
    pw_prop_manyf2pywrap_Dims[0]=8,pw_prop_manyf2pywrap_Dims[1]=size(xa, 2);
    capi_pw_prop_manyf2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_prop_many: failed to create array from the hidden `pw_prop_manyf2pywrap`";
    capi_pw_prop_manyf2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_prop_manyf2pywrap_Dims,pw_prop_manyf2pywrap_Rank,  capi_pw_prop_manyf2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_prop_manyf2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_prop_manyf2pywrap = (double *)(PyArray_DATA(capi_pw_prop_manyf2pywrap_as_array));

    /* Processing variable f2py_xa_d0 */
    f2py_xa_d0 = shape(xa, 0);
    /* Processing variable f2py_xa_d1 */
    f2py_xa_d1 = shape(xa, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_prop_manyf2pywrap,&ta,&tb,xa,&order,&f2py_xa_d0,&f2py_xa_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_prop_manyf2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    /* End of cleaning variable f2py_xa_d1 */
    /* End of cleaning variable f2py_xa_d0 */
    }  /* if (capi_pw_prop_manyf2pywrap_as_array == NULL) ... else of pw_prop_manyf2pywrap */
    /* End of cleaning variable pw_prop_manyf2pywrap */
    } /*if (f2py_success) of order*/
    /* End of cleaning variable order */
    if((PyObject *)capi_xa_as_array!=xa_capi) {
        Py_XDECREF(capi_xa_as_array); }
    }  /* if (capi_xa_as_array == NULL) ... else of xa */
    /* End of cleaning variable xa */
    } /*if (f2py_success) of tb*/
    /* End of cleaning variable tb */
    } /*if (f2py_success) of ta*/
    /* End of cleaning variable ta */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of pw_prop_many ****************************/

/******************************** pw_prop_back ********************************/
static char doc_f2py_rout_pyqist_pq_pw_prop_back[] = "\
res = pw_prop_back(tb,ta,xb,[order])\n\nWrapper for ``pw_prop_back``.\
\n\nParameters\n----------\n"
"tb : input float\n"
"ta : input float\n"
"xb : input rank-1 array('d') with bounds (8)\n"
"\nOther Parameters\n----------------\n"
"order : input int\n"
"\nReturns\n-------\n"
"res : rank-1 array('d') with bounds (8) and pw_prop_backf2pywrap storage";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_prop_back(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *pw_prop_backf2pywrap = NULL;
    npy_intp pw_prop_backf2pywrap_Dims[1] = {-1};
    const int pw_prop_backf2pywrap_Rank = 1;
    PyArrayObject *capi_pw_prop_backf2pywrap_as_array = NULL;
    int capi_pw_prop_backf2pywrap_intent = 0;
    double tb = 0;
    PyObject *tb_capi = Py_None;
    double ta = 0;
    PyObject *ta_capi = Py_None;
    double *xb = NULL;
    npy_intp xb_Dims[1] = {-1};
    const int xb_Rank = 1;
    PyArrayObject *capi_xb_as_array = NULL;
    int capi_xb_intent = 0;
    PyObject *xb_capi = Py_None;
    int order = 0;
    PyObject *order_capi = Py_None;
    static char *capi_kwlist[] = {"tb","ta","xb","order",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:pyqist.pq.pw_prop_back",\
        capi_kwlist,&tb_capi,&ta_capi,&xb_capi,&order_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable ta */
        f2py_success = double_from_pyobj(&ta,ta_capi,"pyqist.pq.pw_prop_back() 2nd argument (ta) can't be converted to double");
    if (f2py_success) {
    /* Processing variable tb */
        f2py_success = double_from_pyobj(&tb,tb_capi,"pyqist.pq.pw_prop_back() 1st argument (tb) can't be converted to double");
    if (f2py_success) {
    /* Processing variable xb */
    xb_Dims[0]=8;
    capi_xb_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_prop_back: failed to create array from the 3rd argument `xb`";
    capi_xb_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,xb_Dims,xb_Rank,  capi_xb_intent,xb_capi,capi_errmess);
    if (capi_xb_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        xb = (double *)(PyArray_DATA(capi_xb_as_array));

    /* Processing variable order */
    if (order_capi != Py_None)
        f2py_success = int_from_pyobj(&order,order_capi,"pyqist.pq.pw_prop_back() 1st keyword (order) can't be converted to int");
    if (f2py_success) {
    /* Processing variable pw_prop_backf2pywrap */
    pw_prop_backf2pywrap_Dims[0]=8;
    capi_pw_prop_backf2pywrap_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_prop_back: failed to create array from the hidden `pw_prop_backf2pywrap`";
    capi_pw_prop_backf2pywrap_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,pw_prop_backf2pywrap_Dims,pw_prop_backf2pywrap_Rank,  capi_pw_prop_backf2pywrap_intent,Py_None,capi_errmess);
    if (capi_pw_prop_backf2pywrap_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        pw_prop_backf2pywrap = (double *)(PyArray_DATA(capi_pw_prop_backf2pywrap_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(pw_prop_backf2pywrap,&tb,&ta,xb,&order);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_pw_prop_backf2pywrap_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_pw_prop_backf2pywrap_as_array == NULL) ... else of pw_prop_backf2pywrap */
    /* End of cleaning variable pw_prop_backf2pywrap */
    } /*if (f2py_success) of order*/
    /* End of cleaning variable order */
    if((PyObject *)capi_xb_as_array!=xb_capi) {
        Py_XDECREF(capi_xb_as_array); }
    }  /* if (capi_xb_as_array == NULL) ... else of xb */
    /* End of cleaning variable xb */
    } /*if (f2py_success) of tb*/
    /* End of cleaning variable tb */
    } /*if (f2py_success) of ta*/
    /* End of cleaning variable ta */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of pw_prop_back ****************************/

/********************************* pw_stts_ab *********************************/
static char doc_f2py_rout_pyqist_pq_pw_stts_ab[] = "\
stm,stt = pw_stts_ab(taua,taub)\n\nWrapper for ``pw_stts_ab``.\
\n\nParameters\n----------\n"
"taua : input float\n"
"taub : input float\n"
"\nReturns\n-------\n"
"stm : rank-2 array('d') with bounds (8,8)\n"
"stt : rank-3 array('d') with bounds (8,8,8)";
/*  */
static PyObject *f2py_rout_pyqist_pq_pw_stts_ab(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double taua = 0;
    PyObject *taua_capi = Py_None;
    double taub = 0;
    PyObject *taub_capi = Py_None;
    double *stm = NULL;
    npy_intp stm_Dims[2] = {-1, -1};
    const int stm_Rank = 2;
    PyArrayObject *capi_stm_as_array = NULL;
    int capi_stm_intent = 0;
    double *stt = NULL;
    npy_intp stt_Dims[3] = {-1, -1, -1};
    const int stt_Rank = 3;
    PyArrayObject *capi_stt_as_array = NULL;
    int capi_stt_intent = 0;
    static char *capi_kwlist[] = {"taua","taub",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:pyqist.pq.pw_stts_ab",\
        capi_kwlist,&taua_capi,&taub_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable taua */
        f2py_success = double_from_pyobj(&taua,taua_capi,"pyqist.pq.pw_stts_ab() 1st argument (taua) can't be converted to double");
    if (f2py_success) {
    /* Processing variable taub */
        f2py_success = double_from_pyobj(&taub,taub_capi,"pyqist.pq.pw_stts_ab() 2nd argument (taub) can't be converted to double");
    if (f2py_success) {
    /* Processing variable stm */
    stm_Dims[0]=8,stm_Dims[1]=8;
    capi_stm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stts_ab: failed to create array from the hidden `stm`";
    capi_stm_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,stm_Dims,stm_Rank,  capi_stm_intent,Py_None,capi_errmess);
    if (capi_stm_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        stm = (double *)(PyArray_DATA(capi_stm_as_array));

    /* Processing variable stt */
    stt_Dims[0]=8,stt_Dims[1]=8,stt_Dims[2]=8;
    capi_stt_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stts_ab: failed to create array from the hidden `stt`";
    capi_stt_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,stt_Dims,stt_Rank,  capi_stt_intent,Py_None,capi_errmess);
    if (capi_stt_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        stt = (double *)(PyArray_DATA(capi_stt_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(&taua,&taub,stm,stt);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NN",capi_stm_as_array,capi_stt_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_stt_as_array == NULL) ... else of stt */
    /* End of cleaning variable stt */
    }  /* if (capi_stm_as_array == NULL) ... else of stm */
    /* End of cleaning variable stm */
    } /*if (f2py_success) of taub*/
    /* End of cleaning variable taub */
    } /*if (f2py_success) of taua*/
    /* End of cleaning variable taua */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of pw_stts_ab *****************************/

/******************************* pw_stt_update *******************************/
static char doc_f2py_rout_pyqist_pq_pw_stt_update[] = "\
new_stm,new_stt = pw_stt_update(ta,tb,xa)\n\nWrapper for ``pw_stt_update``.\
\n\nParameters\n----------\n"
"ta : input float\n"
"tb : input float\n"
"xa : input rank-1 array('d') with bounds (8)\n"
"\nReturns\n-------\n"
"new_stm : rank-2 array('d') with bounds (8,8)\n"
"new_stt : rank-3 array('d') with bounds (8,8,8)";
/*  */
static PyObject *f2py_rout_pyqist_pq_pw_stt_update(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double ta = 0;
    PyObject *ta_capi = Py_None;
    double tb = 0;
    PyObject *tb_capi = Py_None;
    double *xa = NULL;
    npy_intp xa_Dims[1] = {-1};
    const int xa_Rank = 1;
    PyArrayObject *capi_xa_as_array = NULL;
    int capi_xa_intent = 0;
    PyObject *xa_capi = Py_None;
    double *new_stm = NULL;
    npy_intp new_stm_Dims[2] = {-1, -1};
    const int new_stm_Rank = 2;
    PyArrayObject *capi_new_stm_as_array = NULL;
    int capi_new_stm_intent = 0;
    double *new_stt = NULL;
    npy_intp new_stt_Dims[3] = {-1, -1, -1};
    const int new_stt_Rank = 3;
    PyArrayObject *capi_new_stt_as_array = NULL;
    int capi_new_stt_intent = 0;
    static char *capi_kwlist[] = {"ta","tb","xa",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|:pyqist.pq.pw_stt_update",\
        capi_kwlist,&ta_capi,&tb_capi,&xa_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable ta */
        f2py_success = double_from_pyobj(&ta,ta_capi,"pyqist.pq.pw_stt_update() 1st argument (ta) can't be converted to double");
    if (f2py_success) {
    /* Processing variable tb */
        f2py_success = double_from_pyobj(&tb,tb_capi,"pyqist.pq.pw_stt_update() 2nd argument (tb) can't be converted to double");
    if (f2py_success) {
    /* Processing variable xa */
    xa_Dims[0]=8;
    capi_xa_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stt_update: failed to create array from the 3rd argument `xa`";
    capi_xa_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,xa_Dims,xa_Rank,  capi_xa_intent,xa_capi,capi_errmess);
    if (capi_xa_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        xa = (double *)(PyArray_DATA(capi_xa_as_array));

    /* Processing variable new_stm */
    new_stm_Dims[0]=8,new_stm_Dims[1]=8;
    capi_new_stm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stt_update: failed to create array from the hidden `new_stm`";
    capi_new_stm_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,new_stm_Dims,new_stm_Rank,  capi_new_stm_intent,Py_None,capi_errmess);
    if (capi_new_stm_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        new_stm = (double *)(PyArray_DATA(capi_new_stm_as_array));

    /* Processing variable new_stt */
    new_stt_Dims[0]=8,new_stt_Dims[1]=8,new_stt_Dims[2]=8;
    capi_new_stt_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_stt_update: failed to create array from the hidden `new_stt`";
    capi_new_stt_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,new_stt_Dims,new_stt_Rank,  capi_new_stt_intent,Py_None,capi_errmess);
    if (capi_new_stt_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        new_stt = (double *)(PyArray_DATA(capi_new_stt_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(&ta,&tb,xa,new_stm,new_stt);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NN",capi_new_stm_as_array,capi_new_stt_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_new_stt_as_array == NULL) ... else of new_stt */
    /* End of cleaning variable new_stt */
    }  /* if (capi_new_stm_as_array == NULL) ... else of new_stm */
    /* End of cleaning variable new_stm */
    if((PyObject *)capi_xa_as_array!=xa_capi) {
        Py_XDECREF(capi_xa_as_array); }
    }  /* if (capi_xa_as_array == NULL) ... else of xa */
    /* End of cleaning variable xa */
    } /*if (f2py_success) of tb*/
    /* End of cleaning variable tb */
    } /*if (f2py_success) of ta*/
    /* End of cleaning variable ta */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of pw_stt_update ****************************/

/************************* pw_tensor_change_of_basis *************************/
static char doc_f2py_rout_pyqist_pq_pw_tensor_change_of_basis[] = "\
new_stm,new_stt = pw_tensor_change_of_basis(rnof,ron0,old_stm,old_stt)\n\nWrapper for ``pw_tensor_change_of_basis``.\
\n\nParameters\n----------\n"
"rnof : input rank-2 array('d') with bounds (8,8)\n"
"ron0 : input rank-2 array('d') with bounds (8,8)\n"
"old_stm : input rank-2 array('d') with bounds (8,8)\n"
"old_stt : input rank-3 array('d') with bounds (8,8,8)\n"
"\nReturns\n-------\n"
"new_stm : rank-2 array('d') with bounds (8,8)\n"
"new_stt : rank-3 array('d') with bounds (8,8,8)";
/*  */
static PyObject *f2py_rout_pyqist_pq_pw_tensor_change_of_basis(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *rnof = NULL;
    npy_intp rnof_Dims[2] = {-1, -1};
    const int rnof_Rank = 2;
    PyArrayObject *capi_rnof_as_array = NULL;
    int capi_rnof_intent = 0;
    PyObject *rnof_capi = Py_None;
    double *ron0 = NULL;
    npy_intp ron0_Dims[2] = {-1, -1};
    const int ron0_Rank = 2;
    PyArrayObject *capi_ron0_as_array = NULL;
    int capi_ron0_intent = 0;
    PyObject *ron0_capi = Py_None;
    double *old_stm = NULL;
    npy_intp old_stm_Dims[2] = {-1, -1};
    const int old_stm_Rank = 2;
    PyArrayObject *capi_old_stm_as_array = NULL;
    int capi_old_stm_intent = 0;
    PyObject *old_stm_capi = Py_None;
    double *old_stt = NULL;
    npy_intp old_stt_Dims[3] = {-1, -1, -1};
    const int old_stt_Rank = 3;
    PyArrayObject *capi_old_stt_as_array = NULL;
    int capi_old_stt_intent = 0;
    PyObject *old_stt_capi = Py_None;
    double *new_stm = NULL;
    npy_intp new_stm_Dims[2] = {-1, -1};
    const int new_stm_Rank = 2;
    PyArrayObject *capi_new_stm_as_array = NULL;
    int capi_new_stm_intent = 0;
    double *new_stt = NULL;
    npy_intp new_stt_Dims[3] = {-1, -1, -1};
    const int new_stt_Rank = 3;
    PyArrayObject *capi_new_stt_as_array = NULL;
    int capi_new_stt_intent = 0;
    static char *capi_kwlist[] = {"rnof","ron0","old_stm","old_stt",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|:pyqist.pq.pw_tensor_change_of_basis",\
        capi_kwlist,&rnof_capi,&ron0_capi,&old_stm_capi,&old_stt_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable rnof */
    rnof_Dims[0]=8,rnof_Dims[1]=8;
    capi_rnof_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_tensor_change_of_basis: failed to create array from the 1st argument `rnof`";
    capi_rnof_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,rnof_Dims,rnof_Rank,  capi_rnof_intent,rnof_capi,capi_errmess);
    if (capi_rnof_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        rnof = (double *)(PyArray_DATA(capi_rnof_as_array));

    /* Processing variable ron0 */
    ron0_Dims[0]=8,ron0_Dims[1]=8;
    capi_ron0_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_tensor_change_of_basis: failed to create array from the 2nd argument `ron0`";
    capi_ron0_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,ron0_Dims,ron0_Rank,  capi_ron0_intent,ron0_capi,capi_errmess);
    if (capi_ron0_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        ron0 = (double *)(PyArray_DATA(capi_ron0_as_array));

    /* Processing variable old_stm */
    old_stm_Dims[0]=8,old_stm_Dims[1]=8;
    capi_old_stm_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_tensor_change_of_basis: failed to create array from the 3rd argument `old_stm`";
    capi_old_stm_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,old_stm_Dims,old_stm_Rank,  capi_old_stm_intent,old_stm_capi,capi_errmess);
    if (capi_old_stm_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        old_stm = (double *)(PyArray_DATA(capi_old_stm_as_array));

    /* Processing variable old_stt */
    old_stt_Dims[0]=8,old_stt_Dims[1]=8,old_stt_Dims[2]=8;
    capi_old_stt_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_tensor_change_of_basis: failed to create array from the 4th argument `old_stt`";
    capi_old_stt_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,old_stt_Dims,old_stt_Rank,  capi_old_stt_intent,old_stt_capi,capi_errmess);
    if (capi_old_stt_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        old_stt = (double *)(PyArray_DATA(capi_old_stt_as_array));

    /* Processing variable new_stm */
    new_stm_Dims[0]=8,new_stm_Dims[1]=8;
    capi_new_stm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_tensor_change_of_basis: failed to create array from the hidden `new_stm`";
    capi_new_stm_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,new_stm_Dims,new_stm_Rank,  capi_new_stm_intent,Py_None,capi_errmess);
    if (capi_new_stm_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        new_stm = (double *)(PyArray_DATA(capi_new_stm_as_array));

    /* Processing variable new_stt */
    new_stt_Dims[0]=8,new_stt_Dims[1]=8,new_stt_Dims[2]=8;
    capi_new_stt_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "pyqist.pyqist.pq.pw_tensor_change_of_basis: failed to create array from the hidden `new_stt`";
    capi_new_stt_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,new_stt_Dims,new_stt_Rank,  capi_new_stt_intent,Py_None,capi_errmess);
    if (capi_new_stt_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = pyqist_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        new_stt = (double *)(PyArray_DATA(capi_new_stt_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(rnof,ron0,old_stm,old_stt,new_stm,new_stt);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NN",capi_new_stm_as_array,capi_new_stt_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_new_stt_as_array == NULL) ... else of new_stt */
    /* End of cleaning variable new_stt */
    }  /* if (capi_new_stm_as_array == NULL) ... else of new_stm */
    /* End of cleaning variable new_stm */
    if((PyObject *)capi_old_stt_as_array!=old_stt_capi) {
        Py_XDECREF(capi_old_stt_as_array); }
    }  /* if (capi_old_stt_as_array == NULL) ... else of old_stt */
    /* End of cleaning variable old_stt */
    if((PyObject *)capi_old_stm_as_array!=old_stm_capi) {
        Py_XDECREF(capi_old_stm_as_array); }
    }  /* if (capi_old_stm_as_array == NULL) ... else of old_stm */
    /* End of cleaning variable old_stm */
    if((PyObject *)capi_ron0_as_array!=ron0_capi) {
        Py_XDECREF(capi_ron0_as_array); }
    }  /* if (capi_ron0_as_array == NULL) ... else of ron0 */
    /* End of cleaning variable ron0 */
    if((PyObject *)capi_rnof_as_array!=rnof_capi) {
        Py_XDECREF(capi_rnof_as_array); }
    }  /* if (capi_rnof_as_array == NULL) ... else of rnof */
    /* End of cleaning variable rnof */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************** end of pw_tensor_change_of_basis **********************/

/********************************** pw_zmap **********************************/
static char doc_f2py_rout_pyqist_pq_pw_zmap[] = "\
res = pw_zmap(tau,[order])\n\nWrapper for ``pw_zmap``.\
\n\nParameters\n----------\n"
"tau : input float\n"
"\nOther Parameters\n----------------\n"
"order : input int\n"
"\nReturns\n-------\n"
"res : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_pyqist_pq_pw_zmap(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double pw_zmapf2pywrap = 0;
    double tau = 0;
    PyObject *tau_capi = Py_None;
    int order = 0;
    PyObject *order_capi = Py_None;
    static char *capi_kwlist[] = {"tau","order",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:pyqist.pq.pw_zmap",\
        capi_kwlist,&tau_capi,&order_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable tau */
        f2py_success = double_from_pyobj(&tau,tau_capi,"pyqist.pq.pw_zmap() 1st argument (tau) can't be converted to double");
    if (f2py_success) {
    /* Processing variable order */
    if (order_capi != Py_None)
        f2py_success = int_from_pyobj(&order,order_capi,"pyqist.pq.pw_zmap() 1st keyword (order) can't be converted to int");
    if (f2py_success) {
    /* Processing variable pw_zmapf2pywrap */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    (*f2py_func)(&pw_zmapf2pywrap,&tau,&order);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("d",pw_zmapf2pywrap);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    /* End of cleaning variable pw_zmapf2pywrap */
    } /*if (f2py_success) of order*/
    /* End of cleaning variable order */
    } /*if (f2py_success) of tau*/
    /* End of cleaning variable tau */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of pw_zmap *******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_pq_def[] = {
  {"pw_init_v",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_init_v,doc_f2py_rout_pyqist_pq_pw_init_v},
  {"pw_init_n",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_init_n,doc_f2py_rout_pyqist_pq_pw_init_n},
  {"pw_state",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_state,doc_f2py_rout_pyqist_pq_pw_state},
  {"pw_stm",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_stm,doc_f2py_rout_pyqist_pq_pw_stm},
  {"pw_stt",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_stt,doc_f2py_rout_pyqist_pq_pw_stt},
  {"pw_stm_i",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_stm_i,doc_f2py_rout_pyqist_pq_pw_stm_i},
  {"pw_stt_i",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_stt_i,doc_f2py_rout_pyqist_pq_pw_stt_i},
  {"pw_prop_once",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_prop_once,doc_f2py_rout_pyqist_pq_pw_prop_once},
  {"pw_prop_many",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_prop_many,doc_f2py_rout_pyqist_pq_pw_prop_many},
  {"pw_prop_back",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_prop_back,doc_f2py_rout_pyqist_pq_pw_prop_back},
  {"pw_stts_ab",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_stts_ab,doc_f2py_rout_pyqist_pq_pw_stts_ab},
  {"pw_stt_update",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_stt_update,doc_f2py_rout_pyqist_pq_pw_stt_update},
  {"pw_tensor_change_of_basis",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_tensor_change_of_basis,doc_f2py_rout_pyqist_pq_pw_tensor_change_of_basis},
  {"pw_zmap",-1,{{-1}},0,0,NULL,(void *)f2py_rout_pyqist_pq_pw_zmap,doc_f2py_rout_pyqist_pq_pw_zmap},
  {NULL}
};

static void f2py_setup_pq(char *pw_init_v,char *pw_init_n,char *pw_state,char *pw_stm,char *pw_stt,char *pw_stm_i,char *pw_stt_i,char *pw_prop_once,char *pw_prop_many,char *pw_prop_back,char *pw_stts_ab,char *pw_stt_update,char *pw_tensor_change_of_basis,char *pw_zmap) {
  int i_f2py=0;
  f2py_pq_def[i_f2py++].data = pw_init_v;
  f2py_pq_def[i_f2py++].data = pw_init_n;
  f2py_pq_def[i_f2py++].data = pw_state;
  f2py_pq_def[i_f2py++].data = pw_stm;
  f2py_pq_def[i_f2py++].data = pw_stt;
  f2py_pq_def[i_f2py++].data = pw_stm_i;
  f2py_pq_def[i_f2py++].data = pw_stt_i;
  f2py_pq_def[i_f2py++].data = pw_prop_once;
  f2py_pq_def[i_f2py++].data = pw_prop_many;
  f2py_pq_def[i_f2py++].data = pw_prop_back;
  f2py_pq_def[i_f2py++].data = pw_stts_ab;
  f2py_pq_def[i_f2py++].data = pw_stt_update;
  f2py_pq_def[i_f2py++].data = pw_tensor_change_of_basis;
  f2py_pq_def[i_f2py++].data = pw_zmap;
}
extern void F_FUNC(f2pyinitpq,F2PYINITPQ)(void (*)(char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_pq(void) {
  F_FUNC(f2pyinitpq,F2PYINITPQ)(f2py_setup_pq);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {

/*eof routine_defs*/
    {NULL}
};

static PyMethodDef f2py_module_methods[] = {

    {NULL,NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "pyqist",
    NULL,
    -1,
    f2py_module_methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_pyqist(void) {
    int i;
    PyObject *m,*d, *s, *tmp;
    m = pyqist_module = PyModule_Create(&moduledef);
    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
    import_array();
    if (PyErr_Occurred())
        {PyErr_SetString(PyExc_ImportError, "can't initialize module pyqist (failed to import numpy)"); return m;}
    d = PyModule_GetDict(m);
    s = PyUnicode_FromString("1.26.2");
    PyDict_SetItemString(d, "__version__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString(
        "This module 'pyqist' is auto-generated with f2py (version:1.26.2).\nFunctions:\n"
"Fortran 90/95 modules:\n""  pq --- pw_init_v(),pw_init_n(),pw_state(),pw_stm(),pw_stt(),pw_stm_i(),pw_stt_i(),pw_prop_once(),pw_prop_many(),pw_prop_back(),pw_stts_ab(),pw_stt_update(),pw_tensor_change_of_basis(),pw_zmap()"".");
    PyDict_SetItemString(d, "__doc__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString("1.26.2");
    PyDict_SetItemString(d, "__f2py_numpy_version__", s);
    Py_DECREF(s);
    pyqist_error = PyErr_NewException ("pyqist.error", NULL, NULL);
    /*
     * Store the error object inside the dict, so that it could get deallocated.
     * (in practice, this is a module, so it likely will not and cannot.)
     */
    PyDict_SetItemString(d, "_pyqist_error", pyqist_error);
    Py_DECREF(pyqist_error);
    for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
        tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
        Py_DECREF(tmp);
    }














/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "pq", PyFortranObject_New(f2py_pq_def,f2py_init_pq));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
    if (! PyErr_Occurred())
        on_exit(f2py_report_on_exit,(void*)"pyqist");
#endif
    return m;
}
#ifdef __cplusplus
}
#endif
